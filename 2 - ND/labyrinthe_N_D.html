<!DOCTYPE html>
<html lang="fr">

<head>
	<meta charset="cp1252">
	<title>Cube ND minimal</title>
	<style>
		body {
			font-family: Arial;
			margin: 0;
			padding: 20px;
			display: flex;
			flex-direction: column;
			align-items: center
		}

		#grid {
			display: grid;
			gap: 2px;
			margin: 20px 0
		}

		.cell {
			width: 24px;
			height: 24px;
			border: 1px solid #999;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 14px
		}

		.empty {
			background: #eee
		}

		.wall {
			background: #444
		}

		.player {
			background: #2a9;
			border: 2px solid #000
		}

		.goal {
			background: #c22;
			color: #fff
		}
	</style>
</head>

<body>
	<p id="description">
		Ce jeu affiche un labyrinthe en N dimensions, taille N×N×…×N.<br>
		Difficulté 1 : ≥10 chemins. Difficulté 10 : unique chemin.<br>
	</p>

	<label>Taille N : <input id="size" type="number" min="2" max="100" value="10"></label>
	<label>Difficulté 1-10 : <input id="difficulty" type="number" min="1" max="10" value="7"></label>
	<label>Dimensions 1-100 : <input id="dimensions" type="number" min="1" max="100" value="3"></label>
	<label id="slider-wrap">Couche Z : <input id="slider" type="range" min="0" max="4" value="0"></label>
	<span id="axis">(axe actif : Z)</span>
	<p id="message"></p>
	<div style="display:flex;align-items:flex-start;">
		<pre id="tree" style="font-family:monospace;margin:0 20px 0 0"></pre>
		<div>
			<div id="grid"></div>
		</div>
	</div>
	<p>
		Déplacements : flèches (XY), Q (+axe), A (-axe), Z/S (axe actif, si D≥4)
	</p>

	<script>
		const EMPTY = 0, WALL = 1, PLAYER = 2, GOAL = 3;

		let N = parseInt(document.getElementById("size").value, 10);
		let difficulty = parseInt(document.getElementById("difficulty").value, 10);
		let D = parseInt(document.getElementById("dimensions").value, 10);
		let displayAxis = D > 2 ? 2 : 0;
		let activeAxis = D > 2 ? 2 : 0;
		let sliderVals = Array(100).fill(0);
		let cube, player, goal;

		const grid = document.getElementById("grid");
		const slider = document.getElementById("slider");
		const sizeInput = document.getElementById("size");
		const diffInput = document.getElementById("difficulty");
		const dimsInput = document.getElementById("dimensions");
		const message = document.getElementById("message");
		const axisInfo = document.getElementById("axis");
		const sliderWrap = document.getElementById("slider-wrap");
		const tree = document.getElementById("tree");

		// slider dynamique (label d’axe)
		const sliderLabel = document.createElement("span");
		sliderLabel.id = "slider-label";
		sliderWrap.insertBefore(sliderLabel, sliderWrap.childNodes[1]);
		sliderLabel.textContent = (displayAxis + 1);

		// ND helpers
		function makeArray(dim, size, val) {
			if (dim === 0) return val;
			return Array.from({length: size}, () => makeArray(dim - 1, size, val));
		}
		function getND(tab, coord) {
			return coord.slice(0, -1).reduce((a, i) => a[i], tab)[coord[coord.length - 1]];
		}
		function setND(tab, coord, val) {
			let arr = tab;
			for (let i = 0; i < coord.length - 1; i++) arr = arr[coord[i]];
			arr[coord[coord.length - 1]] = val;
		}

		function renderTree() {
			if (D <= 3) {
				tree.style.display = "none";
				tree.innerHTML = "";
				return;
			}
			tree.style.display = "";
			tree.innerHTML = "";
			const pos = player;
			const tgt = goal;
			function isPrefix(arr, prefix) {
				for (let i = 0; i < prefix.length; i++) if (arr[i] !== prefix[i]) return false;
				return true;
			}
			if (!window._treeOpen) window._treeOpen = {};
			const _treeOpen = window._treeOpen;
			function prefixKey(prefix) {return prefix.join("_");}
			const alwaysOpen = new Set();
			for (let i = 0; i <= D; i++) {
				alwaysOpen.add(prefixKey(pos.slice(0, i)));
				alwaysOpen.add(prefixKey(tgt.slice(0, i)));
			}
			function walk(prefix, currentDim, parent, indent) {
				if (currentDim === 3) {
					const coords = prefix.slice();
					for (let i = 0; i < N; i++) {
						const here = getND(cube, coords.concat(i));
						let sym = here === WALL ? "▒" : here === GOAL ? "🎯" : here === PLAYER ? "👤" : "·";
						const leaf = document.createElement("div");
						leaf.style.fontFamily = "monospace";
						leaf.textContent = indent + "|-" + sym;
						parent.appendChild(leaf);
					}
					return;
				}
				for (let i = 0; i < N; i++) {
					// Ne développe que la branche ND affichée
					if (currentDim > 3) {
						if (currentDim === displayAxis) {
							if (i !== player[displayAxis]) continue;
						} else {
							if (i !== player[currentDim]) continue;
						}
					}
					const thisPrefix = prefix.concat(i);
					const thisKey = prefixKey(thisPrefix);
					const open = alwaysOpen.has(thisKey) || _treeOpen[thisKey];

					const node = document.createElement("div");
					node.style.fontFamily = "monospace";
					node.style.marginLeft = (currentDim === D ? 0 : 16) + "px";
					if (currentDim > 3) {
						const btn = document.createElement("button");
						btn.style.width = "1.3em"; btn.style.padding = "0 2px";
						btn.textContent = open ? "–" : "+";
						const isGoalBranch = isPrefix(tgt, thisPrefix) && thisPrefix.length < tgt.length && currentDim === D - thisPrefix.length + 1;
						btn.disabled = isGoalBranch;
						btn.onclick = function (e) {
							e.stopPropagation();
							if (!btn.disabled) {
								_treeOpen[thisKey] = !_treeOpen[thisKey];
								renderTree();
							}
						};
						node.appendChild(btn);
						node.appendChild(document.createTextNode(" " + currentDim));
					}
					parent.appendChild(node);

					if (open && currentDim > 3) {
						walk(thisPrefix, currentDim - 1, parent, indent + "  ");
					}
					if (currentDim === 3) {
						// rien, géré plus haut
					}
				}
			}
			const root = document.createElement("div");
			walk([], D, root, "");
			tree.appendChild(root);
		}

		function resetGame() {
			cube = makeArray(D, N, WALL);
			player = Array(D).fill(0);
			goal = Array(D).fill(N - 1);

			let coords = Array(D).fill(0);
			setND(cube, coords, EMPTY);
			while (!coords.every((v, i) => v === goal[i])) {
				let axes = [];
				for (let i = 0; i < D; i++) if (coords[i] < goal[i]) axes.push(i);
				let ax = axes[Math.random() * axes.length | 0];
				coords = coords.slice();
				coords[ax]++;
				setND(cube, coords, EMPTY);
			}
			const wallProb = 0.8 * (difficulty / 10);
			(function openCells(tab, prefix = []) {
				if (prefix.length === D) {
					if (getND(cube, prefix) === WALL && Math.random() > wallProb)
						setND(cube, prefix, EMPTY);
				} else {
					for (let i = 0; i < N; i++) openCells(tab[i], prefix.concat(i));
				}
			})(cube);

			setND(cube, player, PLAYER);
			setND(cube, goal, GOAL);

			slider.max = N - 1;
			slider.value = player[displayAxis];
			sliderVals = Array(D).fill(0);
			sliderVals[displayAxis] = player[displayAxis];
			grid.style.gridTemplateColumns = `repeat(${N}, 24px)`;
			message.textContent = "";
			sliderWrap.style.display = (D < 3) ? "none" : "inline";
			sliderLabel.textContent = (displayAxis + 1);
			axisInfo.textContent = `(axe actif : ${activeAxis + 1})`;
			render();
		}

		function render() {
			grid.innerHTML = "";
			slider.value = player[displayAxis];
			sliderLabel.textContent = (displayAxis + 1);
			axisInfo.textContent = `(axe actif : ${activeAxis + 1})`;
			if (D === 1) {
				grid.style.gridTemplateColumns = `repeat(${N}, 24px)`;
				for (let x = 0; x < N; x++) {
					const v = getND(cube, [x]);
					const cell = document.createElement("div");
					cell.className = "cell " + (v === EMPTY ? "empty" : v === WALL ? "wall" : v === PLAYER ? "player" : "goal");
					grid.appendChild(cell);
				}
			} else if (D === 2) {
				grid.style.gridTemplateColumns = `repeat(${N}, 24px)`;
				for (let y = 0; y < N; y++)
					for (let x = 0; x < N; x++) {
						const v = getND(cube, [x, y]);
						const cell = document.createElement("div");
						cell.className = "cell " + (v === EMPTY ? "empty" : v === WALL ? "wall" : v === PLAYER ? "player" : "goal");
						grid.appendChild(cell);
					}
			} else {
				const sliceVal = player[displayAxis];
				const coordFixes = [];
				for (let d = 0; d < D; d++) {
					if (d === 0 || d === 1) continue;
					if (d === displayAxis) continue;
					coordFixes[d] = d < player.length ? player[d] : 0;
				}
				grid.style.gridTemplateColumns = `repeat(${N}, 24px)`;
				for (let y = 0; y < N; y++)
					for (let x = 0; x < N; x++) {
						const coords = [];
						for (let d = 0; d < D; d++) {
							if (d === 0) coords.push(x);
							else if (d === 1) coords.push(y);
							else if (d === displayAxis) coords.push(sliceVal);
							else coords.push(coordFixes[d]);
						}
						const v = getND(cube, coords);
						const cell = document.createElement("div");
						cell.className = "cell " + (v === EMPTY ? "empty" : v === WALL ? "wall" : v === PLAYER ? "player" : "goal");
						grid.appendChild(cell);
					}
			}
			renderTree();
		}

		function moveOnAxis(axis, delta) {
			const next = player.slice();
			next[axis] += delta;
			if (next[axis] < 0 || next[axis] >= N) return;
			if (getND(cube, next) === WALL) return;
			if (getND(cube, player) !== GOAL) setND(cube, player, EMPTY);
			player = next;
			// Synchronise grille/coupe ND
			if (D > 2) {
				slider.value = player[displayAxis];
			}
			if (player.every((v, i) => v === goal[i])) {
				resetGame();
				message.textContent = "Bravo, but atteint !";
				return;
			}
			setND(cube, player, PLAYER);
			render();
		}

		document.addEventListener("keydown", e => {
			if (D >= 1 && (e.key === "ArrowRight")) moveOnAxis(0, 1);
			else if (D >= 1 && (e.key === "ArrowLeft")) moveOnAxis(0, -1);
			else if (D >= 2 && (e.key === "ArrowDown")) moveOnAxis(1, 1);
			else if (D >= 2 && (e.key === "ArrowUp")) moveOnAxis(1, -1);
			else if (D >= 3 && (e.key === "a" || e.key === "A")) moveOnAxis(activeAxis, +1);
			else if (D >= 3 && (e.key === "q" || e.key === "Q")) moveOnAxis(activeAxis, -1);
			else if (D >= 3 && (e.key === "z" || e.key === "Z")) {
				if (displayAxis < D - 1) displayAxis++;
				sliderLabel.textContent = (displayAxis + 1);
				render();
			}
			else if (D >= 3 && (e.key === "s" || e.key === "S")) {
				if (displayAxis > 2) displayAxis--;
				sliderLabel.textContent = (displayAxis + 1);
				render();
			}
			else if (D >= 3 && (e.key === "w" || e.key === "W")) {
				if (activeAxis < D - 1) activeAxis++;
				axisInfo.textContent = `(axe actif : ${(activeAxis + 1)})`;
			}
			else if (D >= 3 && (e.key === "x" || e.key === "X")) {
				if (activeAxis > 2) activeAxis--;
				axisInfo.textContent = `(axe actif : ${(activeAxis + 1)})`;
			}
		});

		slider.addEventListener("input", function () {
			player[displayAxis] = parseInt(slider.value, 10);
			render();
		});
		sizeInput.addEventListener("change", () => {
			N = parseInt(sizeInput.value, 10);
			resetGame();
		});
		diffInput.addEventListener("change", () => {
			difficulty = parseInt(diffInput.value, 10);
			resetGame();
		});
		dimsInput.addEventListener("change", () => {
			D = parseInt(dimsInput.value, 10);
			displayAxis = D > 2 ? 2 : 0;
			activeAxis = D > 2 ? 2 : 0;
			sliderVals = Array(D).fill(0);
			resetGame();
		});
		resetGame();
	</script>

</body>

</html>
