<!DOCTYPE html>
<html lang="fr">

<head>
	<meta charset="cp1252">
	<title>Cube ND minimal</title>
	<style>
		body {
			font-family: Arial;
			margin: 0;
			padding: 20px;
			display: flex;
			flex-direction: column;
			align-items: center
		}

		#grid {
			display: grid;
			gap: 2px;
			margin: 20px 0
		}

		.cell {
			width: 24px;
			height: 24px;
			border: 1px solid #999;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 14px
		}

		.empty {
			background: #eee
		}

		.wall {
			background: #444
		}

		.player {
			background: #2a9;
			border: 2px solid #000
		}

		.goal {
			background: #c22;
			color: #fff
		}
	</style>
</head>

<body>
	<p id="description">
		Ce jeu affiche un labyrinthe en N dimensions, taille N×N×…×N.<br>
		Difficulté 1 : ≥10 chemins. Difficulté 10 : unique chemin.<br>
	</p>

	<label>Taille N : <input id="size" type="number" min="2" max="100" value="5"></label>
	<label>Difficulté 1-10 : <input id="difficulty" type="number" min="1" max="10" value="5"></label>
	<label>Dimensions 1-100 : <input id="dimensions" type="number" min="1" max="100" value="3"></label>
	<label id="slider-wrap">Couche Z : <input id="slider" type="range" min="0" max="4" value="0"></label>
	<span id="axis">(axe actif : Z)</span>
	<p id="message"></p>
	<div style="display:flex;align-items:flex-start;">
		<pre id="tree" style="font-family:monospace;margin:0 20px 0 0"></pre>
		<div>
			<div id="grid"></div>
		</div>
	</div>
	<p>
		Déplacements : flèches (XY), Q (+axe), A (-axe), Z/S (axe actif, si D≥4)
	</p>

	<script>
		const EMPTY = 0, WALL = 1, PLAYER = 2, GOAL = 3;

		let N = parseInt(document.getElementById("size").value, 10);
		let difficulty = parseInt(document.getElementById("difficulty").value, 10);
		let D = parseInt(document.getElementById("dimensions").value, 10);
		let activeAxis = 2;
		let cube, player, goal;

		const grid = document.getElementById("grid");
		const slider = document.getElementById("slider");
		const sizeInput = document.getElementById("size");
		const diffInput = document.getElementById("difficulty");
		const dimsInput = document.getElementById("dimensions");
		const message = document.getElementById("message");
		const axisInfo = document.getElementById("axis");
		const sliderWrap = document.getElementById("slider-wrap");

		function makeArray(dim, size, val) {
			if (dim === 0) return val;
			return Array.from({length: size}, () => makeArray(dim - 1, size, val));
		}
		function getND(tab, coord) {
			return coord.slice(0, -1).reduce((a, i) => a[i], tab)[coord[coord.length - 1]];
		}
		function setND(tab, coord, val) {
			let arr = tab;
			for (let i = 0; i < coord.length - 1; i++) arr = arr[coord[i]];
			arr[coord[coord.length - 1]] = val;
		}

		function renderTree() {
			const tree = document.getElementById("tree");
			tree.innerHTML = ""; // reset

			function isPrefix(arr, prefix) {
				for (let i = 0; i < prefix.length; i++) if (arr[i] !== prefix[i]) return false;
				return true;
			}
			const pos = player;
			const tgt = goal;

			// État d'ouverture/repli des branches (persistant via attributs data)
			if (!window._treeOpen) window._treeOpen = {};
			const _treeOpen = window._treeOpen;

			// Chemin joueur et but (à toujours déplier)
			function prefixKey(prefix) {return prefix.join("_");}
			const alwaysOpen = new Set();
			for (let i = 0; i <= D; i++) {
				alwaysOpen.add(prefixKey(pos.slice(0, i)));
				alwaysOpen.add(prefixKey(tgt.slice(0, i)));
			}

			function walk(prefix, depth, parent) {
				if (depth === D) {
					let here = getND(cube, prefix);
					let sym = here === WALL ? "▒" : here === GOAL ? "🎯" : here === PLAYER ? "👤" : "·";
					const leaf = document.createElement("div");
					leaf.style.marginLeft = depth * 16 + "px";
					leaf.textContent = sym;
					parent.appendChild(leaf);
					return;
				}
				const thisKey = prefixKey(prefix);
				const open = alwaysOpen.has(thisKey) || _treeOpen[thisKey];
				const node = document.createElement("div");
				node.style.marginLeft = depth * 16 + "px";
				const btn = document.createElement("button");
				btn.style.width = "1.3em"; btn.style.padding = "0 2px";
				btn.textContent = open ? "–" : "+";
				// Désactive bouton sur branche sortie (goal)
				const isGoalBranch = isPrefix(tgt, prefix) && prefix.length < tgt.length;
				btn.disabled = isGoalBranch && tgt.slice(0, prefix.length).join("_") === prefix.join("_");
				btn.onclick = function (e) {
					e.stopPropagation();
					if (!btn.disabled) {
						_treeOpen[thisKey] = !_treeOpen[thisKey];
						renderTree();
					}
				};
				node.appendChild(btn);
				node.appendChild(document.createTextNode(" " + (prefix.length < D ? prefix[prefix.length - 1] ?? "root" : "")));
				parent.appendChild(node);
				if (open) {
					for (let i = 0; i < N; i++) {
						walk(prefix.concat(i), depth + 1, parent);
					}
				}
			}
			const root = document.createElement("div");
			walk([], 0, root);
			tree.appendChild(root);
		}


		function resetGame() {
			cube = makeArray(D, N, WALL);
			player = Array(D).fill(0);
			goal = Array(D).fill(N - 1);

			let coords = Array(D).fill(0);
			setND(cube, coords, EMPTY);
			while (!coords.every((v, i) => v === goal[i])) {
				let axes = [];
				for (let i = 0; i < D; i++) if (coords[i] < goal[i]) axes.push(i);
				let ax = axes[Math.random() * axes.length | 0];
				coords = coords.slice();
				coords[ax]++;
				setND(cube, coords, EMPTY);
			}
			const wallProb = 0.8 * (difficulty / 10);
			(function openCells(tab, prefix = []) {
				if (prefix.length === D) {
					if (getND(cube, prefix) === WALL && Math.random() > wallProb)
						setND(cube, prefix, EMPTY);
				} else {
					for (let i = 0; i < N; i++) openCells(tab[i], prefix.concat(i));
				}
			})(cube);

			setND(cube, player, PLAYER);
			setND(cube, goal, GOAL);

			slider.max = N - 1;
			slider.value = 0;
			grid.style.gridTemplateColumns = `repeat(${N}, 24px)`;
			message.textContent = "";
			sliderWrap.style.display = (D < 3) ? "none" : "inline";
			axisInfo.textContent = `(axe actif : ${["X", "Y", "Z"][activeAxis] ?? activeAxis})`;
			render();
		}

		function render() {
			grid.innerHTML = "";
			if (D === 1) {
				grid.style.gridTemplateColumns = `repeat(${N}, 24px)`;
				for (let x = 0; x < N; x++) {
					const v = getND(cube, [x]);
					const cell = document.createElement("div");
					cell.className = "cell " + (v === EMPTY ? "empty" : v === WALL ? "wall" : v === PLAYER ? "player" : "goal");
					grid.appendChild(cell);
				}
			}
			else if (D === 2) {
				grid.style.gridTemplateColumns = `repeat(${N}, 24px)`;
				for (let y = 0; y < N; y++)
					for (let x = 0; x < N; x++) {
						const v = getND(cube, [x, y]);
						const cell = document.createElement("div");
						cell.className = "cell " + (v === EMPTY ? "empty" : v === WALL ? "wall" : v === PLAYER ? "player" : "goal");
						grid.appendChild(cell);
					}
			}
			else {
				const z = parseInt(slider.value, 10);
				grid.style.gridTemplateColumns = `repeat(${N}, 24px)`;
				for (let y = 0; y < N; y++)
					for (let x = 0; x < N; x++) {
						let coords = [x, y];
						while (coords.length < D) {
							if (coords.length === 2) coords.push(z);
							else coords.push(0);
						}
						const v = getND(cube, coords);
						const cell = document.createElement("div");
						cell.className = "cell " + (v === EMPTY ? "empty" : v === WALL ? "wall" : v === PLAYER ? "player" : "goal");
						grid.appendChild(cell);
					}
			}
			renderTree();
		}

		function moveOnAxis(axis, delta) {
			const next = player.slice();
			next[axis] += delta;
			if (next[axis] < 0 || next[axis] >= N) return;
			if (getND(cube, next) === WALL) return;
			if (getND(cube, player) !== GOAL) setND(cube, player, EMPTY);
			player = next;
			if (player.every((v, i) => v === goal[i])) {
				resetGame();
				message.textContent = "Bravo, but atteint !";
				return;
			}
			setND(cube, player, PLAYER);
			if (D >= 3 && activeAxis === 2) slider.value = player[2];
			render();
		}

		document.addEventListener("keydown", e => {
			if (D >= 1 && (e.key === "ArrowRight")) moveOnAxis(0, 1);
			else if (D >= 1 && (e.key === "ArrowLeft")) moveOnAxis(0, -1);
			else if (D >= 2 && (e.key === "ArrowDown")) moveOnAxis(1, 1);
			else if (D >= 2 && (e.key === "ArrowUp")) moveOnAxis(1, -1);
			else if (D >= 3 && (e.key === "a" || e.key === "A")) moveOnAxis(activeAxis, +1);
			else if (D >= 3 && (e.key === "q" || e.key === "Q")) moveOnAxis(activeAxis, -1);
			else if (D >= 4 && (e.key === "z" || e.key === "Z")) {
				if (activeAxis < D - 1) activeAxis++;
				axisInfo.textContent = `(axe actif : ${["X", "Y", "Z"][activeAxis] ?? activeAxis})`;
			}
			else if (D >= 4 && (e.key === "s" || e.key === "S")) {
				if (activeAxis > 2) activeAxis--;
				axisInfo.textContent = `(axe actif : ${["X", "Y", "Z"][activeAxis] ?? activeAxis})`;
			}
		});

		slider.addEventListener("input", render);

		sizeInput.addEventListener("change", () => {
			N = parseInt(sizeInput.value, 10);
			resetGame();
		});
		diffInput.addEventListener("change", () => {
			difficulty = parseInt(diffInput.value, 10);
			resetGame();
		});
		dimsInput.addEventListener("change", () => {
			D = parseInt(dimsInput.value, 10);
			activeAxis = Math.min(activeAxis, Math.max(2, D - 1));
			resetGame();
		});
		resetGame();
	</script>

</body>

</html>
